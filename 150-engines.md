第十五章 引擎
==============

引擎表示服从时间抢占的运算过程。换句话说，一个引擎下面的运算过程是普通的程序作为定时器可抢占的进程。

一个引擎用三个参数来调用：

- 分配时间片（运行时间单元）的数目
- 成功过程
- 失败过程

如果引擎的计算在分配的时间片内完成了，那么就把计算的结果作为参数来调用成功过程，如果没有计算完成，那么把未计算完的部分作为参数来调用失败过程。

比如，考虑一个引擎，其下的运算是一个循环，该循环打印非负整数的序列。该引擎用下面的make-engine过程（后面会定义该过程）创建，make-engine接受一个程序（即该引擎下面的计算过程）为参数，并返回对应的引擎。

(define printn-engine
  (make-engine
    (lambda ()
      (let loop ((i 0))
        (display i)
        (display " ")
        (loop (+ i 1))))))

下面调用pritn-engine：

(define *more* #f)
(printn-engine 50 list (lambda (ne) (set! *more* ne)))
=>  0 1 2 3 4 5 6 7 8 9

也就是循环打印到某个特定的数（这里是9）然后就失败(fail)了，因为时钟中断了。然而，我们定义的失败过程把fail掉的引擎赋值给了全局变量`*more*`。这样我们就可以从上个引擎中断的地方恢复：

(*more* 50 list (lambda (ne) (set! *more* ne)))
=>  10 11 12 13 14 15 16 17 18 19

我们现在来构建引擎，使用call/cc来捕获一个失败引擎未完成的计算。首先我们会构造一个flat引擎，也就是说该引擎的计算中不能运行其他引擎。稍后我们会让代码更通用，实现nestable引擎，这样的引擎可以调用其他引擎。但是不管那种引擎，我们都需要一个定时的东西，时钟（clock）。

## 15.1 时钟

我们的引擎假设有一个全局的时钟或可中断的定时器来记录程序运行的时间片。我们假设下面的时钟接口——你通常应该很容易把Scheme提供的时钟接口（如果有的话）打包成下面这种类型。（附录D用Scheme的Guile方言定义了一个时钟）

我们的clock过程的内部状态包括以下两项：

1. 剩余的时间片的数目，以及
2. 一个中断处理器(handler)，当时钟的时间片用完了的时候被调用。

clock允许下面的操作：

1. (clock 'set‑handler h)设置中断处理器为h。
2. (clock 'set n)把时钟的剩余时间片重置为n，返回之前的值。

n的取值范围是所有非负整数以及一个叫*infinity*的原子。一个时钟如果有*infinity*的时间片永远不会终止，所以也用不着设置中断处理器。这样的时钟总是“静止的”或“停止的”（定时器的工作就是：减到0并中断，而这样的时钟永远不会减到0并中断，所以处于“非工作”状态）。让一个时钟停止只要把时间片设为*infinity*即可。

时钟的处理器被设置为一个程序，比如：

(clock 'set-handler
  (lambda ()
    (error "Say goodnight, cat!")))

(clock 'set 9)

这样9个时间片过去后会产生一个错误，并且显示的错误信息是"Say goodnight, cat!"

## 15.2 flat引擎

我们将首先设置时钟的中断处理器。注意这个处理器只有在“工作”状态的时钟用完时间片后才会被调用。这只有引擎计算失败时才发生，因为只有引擎设置时钟。

处理器捕获当前的续延，也就是当前失败引擎的剩余计算部分。这个续延被保存到全局的*engine-escape*变量中。该变量存放当前引擎的续延。因此时钟处理器捕获失败引擎的剩余部分并把它发送到引擎代码的出口。这样所需的失败处理才能执行。

让我们来看一下引擎代码的内部。如上所述，make-engine接受一个程序并为之构造一个引擎：

首先我们引入变量ticks-left和engine-succeeded?。前者保存引擎的程序应该在多少时间片内完成。后者是一个标志，表示引擎是否成功。

我们接下来在两层对call/cc的调用中执行引擎的程序。第一个call/cc捕获的续延被失败




